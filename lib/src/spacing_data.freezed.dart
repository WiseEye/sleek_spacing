// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'spacing_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$SleekSpacingDataTearOff {
  const _$SleekSpacingDataTearOff();

  _SleekSpacingData _(
      {required double extraSmall,
      required double small,
      required double normal,
      required double medium,
      required double big,
      required double extraBig}) {
    return _SleekSpacingData(
      extraSmall: extraSmall,
      small: small,
      normal: normal,
      medium: medium,
      big: big,
      extraBig: extraBig,
    );
  }
}

/// @nodoc
const $SleekSpacingData = _$SleekSpacingDataTearOff();

/// @nodoc
mixin _$SleekSpacingData {
  double get extraSmall => throw _privateConstructorUsedError;
  double get small => throw _privateConstructorUsedError;
  double get normal => throw _privateConstructorUsedError;
  double get medium => throw _privateConstructorUsedError;
  double get big => throw _privateConstructorUsedError;
  double get extraBig => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SleekSpacingDataCopyWith<SleekSpacingData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SleekSpacingDataCopyWith<$Res> {
  factory $SleekSpacingDataCopyWith(
          SleekSpacingData value, $Res Function(SleekSpacingData) then) =
      _$SleekSpacingDataCopyWithImpl<$Res>;
  $Res call(
      {double extraSmall,
      double small,
      double normal,
      double medium,
      double big,
      double extraBig});
}

/// @nodoc
class _$SleekSpacingDataCopyWithImpl<$Res>
    implements $SleekSpacingDataCopyWith<$Res> {
  _$SleekSpacingDataCopyWithImpl(this._value, this._then);

  final SleekSpacingData _value;
  // ignore: unused_field
  final $Res Function(SleekSpacingData) _then;

  @override
  $Res call({
    Object? extraSmall = freezed,
    Object? small = freezed,
    Object? normal = freezed,
    Object? medium = freezed,
    Object? big = freezed,
    Object? extraBig = freezed,
  }) {
    return _then(_value.copyWith(
      extraSmall: extraSmall == freezed
          ? _value.extraSmall
          : extraSmall // ignore: cast_nullable_to_non_nullable
              as double,
      small: small == freezed
          ? _value.small
          : small // ignore: cast_nullable_to_non_nullable
              as double,
      normal: normal == freezed
          ? _value.normal
          : normal // ignore: cast_nullable_to_non_nullable
              as double,
      medium: medium == freezed
          ? _value.medium
          : medium // ignore: cast_nullable_to_non_nullable
              as double,
      big: big == freezed
          ? _value.big
          : big // ignore: cast_nullable_to_non_nullable
              as double,
      extraBig: extraBig == freezed
          ? _value.extraBig
          : extraBig // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
abstract class _$SleekSpacingDataCopyWith<$Res>
    implements $SleekSpacingDataCopyWith<$Res> {
  factory _$SleekSpacingDataCopyWith(
          _SleekSpacingData value, $Res Function(_SleekSpacingData) then) =
      __$SleekSpacingDataCopyWithImpl<$Res>;
  @override
  $Res call(
      {double extraSmall,
      double small,
      double normal,
      double medium,
      double big,
      double extraBig});
}

/// @nodoc
class __$SleekSpacingDataCopyWithImpl<$Res>
    extends _$SleekSpacingDataCopyWithImpl<$Res>
    implements _$SleekSpacingDataCopyWith<$Res> {
  __$SleekSpacingDataCopyWithImpl(
      _SleekSpacingData _value, $Res Function(_SleekSpacingData) _then)
      : super(_value, (v) => _then(v as _SleekSpacingData));

  @override
  _SleekSpacingData get _value => super._value as _SleekSpacingData;

  @override
  $Res call({
    Object? extraSmall = freezed,
    Object? small = freezed,
    Object? normal = freezed,
    Object? medium = freezed,
    Object? big = freezed,
    Object? extraBig = freezed,
  }) {
    return _then(_SleekSpacingData(
      extraSmall: extraSmall == freezed
          ? _value.extraSmall
          : extraSmall // ignore: cast_nullable_to_non_nullable
              as double,
      small: small == freezed
          ? _value.small
          : small // ignore: cast_nullable_to_non_nullable
              as double,
      normal: normal == freezed
          ? _value.normal
          : normal // ignore: cast_nullable_to_non_nullable
              as double,
      medium: medium == freezed
          ? _value.medium
          : medium // ignore: cast_nullable_to_non_nullable
              as double,
      big: big == freezed
          ? _value.big
          : big // ignore: cast_nullable_to_non_nullable
              as double,
      extraBig: extraBig == freezed
          ? _value.extraBig
          : extraBig // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_SleekSpacingData
    with DiagnosticableTreeMixin
    implements _SleekSpacingData {
  const _$_SleekSpacingData(
      {required this.extraSmall,
      required this.small,
      required this.normal,
      required this.medium,
      required this.big,
      required this.extraBig});

  @override
  final double extraSmall;
  @override
  final double small;
  @override
  final double normal;
  @override
  final double medium;
  @override
  final double big;
  @override
  final double extraBig;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SleekSpacingData._(extraSmall: $extraSmall, small: $small, normal: $normal, medium: $medium, big: $big, extraBig: $extraBig)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SleekSpacingData._'))
      ..add(DiagnosticsProperty('extraSmall', extraSmall))
      ..add(DiagnosticsProperty('small', small))
      ..add(DiagnosticsProperty('normal', normal))
      ..add(DiagnosticsProperty('medium', medium))
      ..add(DiagnosticsProperty('big', big))
      ..add(DiagnosticsProperty('extraBig', extraBig));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SleekSpacingData &&
            (identical(other.extraSmall, extraSmall) ||
                const DeepCollectionEquality()
                    .equals(other.extraSmall, extraSmall)) &&
            (identical(other.small, small) ||
                const DeepCollectionEquality().equals(other.small, small)) &&
            (identical(other.normal, normal) ||
                const DeepCollectionEquality().equals(other.normal, normal)) &&
            (identical(other.medium, medium) ||
                const DeepCollectionEquality().equals(other.medium, medium)) &&
            (identical(other.big, big) ||
                const DeepCollectionEquality().equals(other.big, big)) &&
            (identical(other.extraBig, extraBig) ||
                const DeepCollectionEquality()
                    .equals(other.extraBig, extraBig)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(extraSmall) ^
      const DeepCollectionEquality().hash(small) ^
      const DeepCollectionEquality().hash(normal) ^
      const DeepCollectionEquality().hash(medium) ^
      const DeepCollectionEquality().hash(big) ^
      const DeepCollectionEquality().hash(extraBig);

  @JsonKey(ignore: true)
  @override
  _$SleekSpacingDataCopyWith<_SleekSpacingData> get copyWith =>
      __$SleekSpacingDataCopyWithImpl<_SleekSpacingData>(this, _$identity);
}

abstract class _SleekSpacingData implements SleekSpacingData {
  const factory _SleekSpacingData(
      {required double extraSmall,
      required double small,
      required double normal,
      required double medium,
      required double big,
      required double extraBig}) = _$_SleekSpacingData;

  @override
  double get extraSmall => throw _privateConstructorUsedError;
  @override
  double get small => throw _privateConstructorUsedError;
  @override
  double get normal => throw _privateConstructorUsedError;
  @override
  double get medium => throw _privateConstructorUsedError;
  @override
  double get big => throw _privateConstructorUsedError;
  @override
  double get extraBig => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SleekSpacingDataCopyWith<_SleekSpacingData> get copyWith =>
      throw _privateConstructorUsedError;
}
